// This file is autogenerated by './gen.rb'. Do not edit.

message_info_t
dispatch_method (cte_t *slot, message_info_t info)
{
  error_t error = no_error;
  switch (get_message_label (info))
    {
    case METHOD_CNode_Copy:
      {
        word_t dest_index = (word_t)get_mr (0);
        uint8_t dest_depth = (uint8_t)get_mr (1);
        word_t src_index = (word_t)get_mr (2);
        uint8_t src_depth = (uint8_t)get_mr (3);
        cap_rights_t rights = (cap_rights_t)get_mr (4);
        cte_t *src_root;

        dbg_printf ("ubm_CNode_Copy ");

        if (cap_type (slot) != cap_CNode)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 5)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        src_root = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf (
            "(cap:%s, dest_index=%#lx, dest_depth=%hhu, src_root=cap:%s, "
            "src_index=%#lx, src_depth=%hhu, rights=%#lx)\n",
            cap_type_string (slot), dest_index, dest_depth,
            cap_type_string (src_root), src_index, src_depth, rights);

        return CNode_Copy (slot, dest_index, dest_depth, src_root, src_index,
                           src_depth, rights);
        break;
      }
    case METHOD_CNode_Delete:
      {
        word_t index = (word_t)get_mr (0);
        uint8_t depth = (uint8_t)get_mr (1);

        dbg_printf ("ubm_CNode_Delete ");

        if (cap_type (slot) != cap_CNode)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 2)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, index=%#lx, depth=%hhu)\n",
                    cap_type_string (slot), index, depth);

        return CNode_Delete (slot, index, depth);
        break;
      }
    case METHOD_CNode_Mint:
      {
        word_t dest_index = (word_t)get_mr (0);
        uint8_t dest_depth = (uint8_t)get_mr (1);
        word_t src_index = (word_t)get_mr (2);
        uint8_t src_depth = (uint8_t)get_mr (3);
        cap_rights_t rights = (cap_rights_t)get_mr (4);
        word_t badge = (word_t)get_mr (5);
        cte_t *src_root;

        dbg_printf ("ubm_CNode_Mint ");

        if (cap_type (slot) != cap_CNode)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 6)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        src_root = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf (
            "(cap:%s, dest_index=%#lx, dest_depth=%hhu, src_root=cap:%s, "
            "src_index=%#lx, src_depth=%hhu, rights=%#lx, badge=%#lx)\n",
            cap_type_string (slot), dest_index, dest_depth,
            cap_type_string (src_root), src_index, src_depth, rights, badge);

        return CNode_Mint (slot, dest_index, dest_depth, src_root, src_index,
                           src_depth, rights, badge);
        break;
      }
    case METHOD_CNode_Revoke:
      {
        word_t index = (word_t)get_mr (0);
        uint8_t depth = (uint8_t)get_mr (1);

        dbg_printf ("ubm_CNode_Revoke ");

        if (cap_type (slot) != cap_CNode)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 2)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, index=%#lx, depth=%hhu)\n",
                    cap_type_string (slot), index, depth);

        return CNode_Revoke (slot, index, depth);
        break;
      }
    case METHOD_CNode_DebugPrint:
      {

        dbg_printf ("ubm_CNode_DebugPrint ");

        if (cap_type (slot) != cap_CNode)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return CNode_DebugPrint (slot);
        break;
      }
    case METHOD_TCB_Configure:
      {
        word_t fault_ep = (word_t)get_mr (0);
        word_t cspace_root_data = (word_t)get_mr (1);
        word_t vspace_root_data = (word_t)get_mr (2);
        word_t buffer = (word_t)get_mr (3);
        cte_t *cspace_root;
        cte_t *vspace_root;
        cte_t *buffer_frame;

        dbg_printf ("ubm_TCB_Configure ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 4)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 3)
          return return_ipc (truncated_message, 0);

        cspace_root = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }
        vspace_root = lookup_cap_slot_this_tcb (get_cap (1), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 1\n");
            set_mr (0, 1);
            return return_ipc (error, 1);
          }
        buffer_frame = lookup_cap_slot_this_tcb (get_cap (2), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 2\n");
            set_mr (0, 2);
            return return_ipc (error, 1);
          }

        dbg_printf (
            "(cap:%s, fault_ep=%#lx, cspace_root=cap:%s, "
            "cspace_root_data=%#lx, vspace_root=cap:%s, "
            "vspace_root_data=%#lx, buffer=%#lx, buffer_frame=cap:%s)\n",
            cap_type_string (slot), fault_ep, cap_type_string (cspace_root),
            cspace_root_data, cap_type_string (vspace_root), vspace_root_data,
            buffer, cap_type_string (buffer_frame));

        return TCB_Configure (slot, fault_ep, cspace_root, cspace_root_data,
                              vspace_root, vspace_root_data, buffer,
                              buffer_frame);
        break;
      }
    case METHOD_TCB_CopyRegisters:
      {
        bool suspend_source = (bool)get_mr (0);
        bool resume_target = (bool)get_mr (1);
        bool transfer_frame = (bool)get_mr (2);
        bool transfer_integer = (bool)get_mr (3);
        word_t arch_flags = (word_t)get_mr (4);
        cte_t *source;

        dbg_printf ("ubm_TCB_CopyRegisters ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 5)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        source = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf (
            "(cap:%s, source=cap:%s, suspend_source=%d, resume_target=%d, "
            "transfer_frame=%d, transfer_integer=%d, arch_flags=%#lx)\n",
            cap_type_string (slot), cap_type_string (source), suspend_source,
            resume_target, transfer_frame, transfer_integer, arch_flags);

        return TCB_CopyRegisters (slot, source, suspend_source, resume_target,
                                  transfer_frame, transfer_integer,
                                  arch_flags);
        break;
      }
    case METHOD_TCB_ReadRegisters:
      {
        bool suspend_source = (bool)get_mr (0);
        word_t arch_flags = (word_t)get_mr (1);
        word_t count = (word_t)get_mr (2);
        user_context_t *regs = (user_context_t *)get_mr (3);

        dbg_printf ("ubm_TCB_ReadRegisters ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 4)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, suspend_source=%d, arch_flags=%#lx, count=%#lx, "
                    "regs=%p)\n",
                    cap_type_string (slot), suspend_source, arch_flags, count,
                    regs);

        return TCB_ReadRegisters (slot, suspend_source, arch_flags, count,
                                  regs);
        break;
      }
    case METHOD_TCB_Resume:
      {

        dbg_printf ("ubm_TCB_Resume ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return TCB_Resume (slot);
        break;
      }
    case METHOD_TCB_BindNotification:
      {

        cte_t *notification;

        dbg_printf ("ubm_TCB_BindNotification ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        notification = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf ("(cap:%s, notification=cap:%s)\n", cap_type_string (slot),
                    cap_type_string (notification));

        return TCB_BindNotification (slot, notification);
        break;
      }
    case METHOD_TCB_SetAffinity:
      {
        word_t affinity = (word_t)get_mr (0);

        dbg_printf ("ubm_TCB_SetAffinity ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 1)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, affinity=%#lx)\n", cap_type_string (slot),
                    affinity);

        return TCB_SetAffinity (slot, affinity);
        break;
      }
    case METHOD_TCB_SetIPCBuffer:
      {
        word_t buffer = (word_t)get_mr (0);
        cte_t *buffer_frame;

        dbg_printf ("ubm_TCB_SetIPCBuffer ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 1)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        buffer_frame = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf ("(cap:%s, buffer=%#lx, buffer_frame=cap:%s)\n",
                    cap_type_string (slot), buffer,
                    cap_type_string (buffer_frame));

        return TCB_SetIPCBuffer (slot, buffer, buffer_frame);
        break;
      }
    case METHOD_TCB_SetSpace:
      {
        word_t fault_ep = (word_t)get_mr (0);
        word_t cspace_root_data = (word_t)get_mr (1);
        word_t vspace_root_data = (word_t)get_mr (2);
        cte_t *cspace_root;
        cte_t *vspace_root;

        dbg_printf ("ubm_TCB_SetSpace ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 3)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 2)
          return return_ipc (truncated_message, 0);

        cspace_root = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }
        vspace_root = lookup_cap_slot_this_tcb (get_cap (1), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 1\n");
            set_mr (0, 1);
            return return_ipc (error, 1);
          }

        dbg_printf ("(cap:%s, fault_ep=%#lx, cspace_root=cap:%s, "
                    "cspace_root_data=%#lx, vspace_root=cap:%s, "
                    "vspace_root_data=%#lx)\n",
                    cap_type_string (slot), fault_ep,
                    cap_type_string (cspace_root), cspace_root_data,
                    cap_type_string (vspace_root), vspace_root_data);

        return TCB_SetSpace (slot, fault_ep, cspace_root, cspace_root_data,
                             vspace_root, vspace_root_data);
        break;
      }
    case METHOD_TCB_SetTLSBase:
      {
        word_t tls_base = (word_t)get_mr (0);

        dbg_printf ("ubm_TCB_SetTLSBase ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 1)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, tls_base=%#lx)\n", cap_type_string (slot),
                    tls_base);

        return TCB_SetTLSBase (slot, tls_base);
        break;
      }
    case METHOD_TCB_Suspend:
      {

        dbg_printf ("ubm_TCB_Suspend ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return TCB_Suspend (slot);
        break;
      }
    case METHOD_TCB_WriteRegisters:
      {
        bool resume_target = (bool)get_mr (0);
        word_t arch_flags = (word_t)get_mr (1);
        word_t count = (word_t)get_mr (2);
        user_context_t *regs = (user_context_t *)get_mr (3);

        dbg_printf ("ubm_TCB_WriteRegisters ");

        if (cap_type (slot) != cap_TCB)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 4)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, resume_target=%d, arch_flags=%#lx, count=%#lx, "
                    "regs=%p)\n",
                    cap_type_string (slot), resume_target, arch_flags, count,
                    regs);

        return TCB_WriteRegisters (slot, resume_target, arch_flags, count,
                                   regs);
        break;
      }
    case METHOD_Untyped_Retype:
      {
        word_t type = (word_t)get_mr (0);
        word_t size_bits = (word_t)get_mr (1);
        word_t node_index = (word_t)get_mr (2);
        uint8_t node_depth = (uint8_t)get_mr (3);
        word_t node_offset = (word_t)get_mr (4);
        word_t num_objects = (word_t)get_mr (5);
        cte_t *root;

        dbg_printf ("ubm_Untyped_Retype ");

        if (cap_type (slot) != cap_Untyped)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 6)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        root = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf ("(cap:%s, type=%#lx, size_bits=%#lx, root=cap:%s, "
                    "node_index=%#lx, node_depth=%hhu, node_offset=%#lx, "
                    "num_objects=%#lx)\n",
                    cap_type_string (slot), type, size_bits,
                    cap_type_string (root), node_index, node_depth,
                    node_offset, num_objects);

        return Untyped_Retype (slot, type, size_bits, root, node_index,
                               node_depth, node_offset, num_objects);
        break;
      }
    case METHOD_X86_IOPort_In8:
      {
        word_t port = (word_t)get_mr (0);

        dbg_printf ("ubm_X86_IOPort_In8 ");

        if (cap_type (slot) != cap_X86_IOPort)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 1)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, port=%#lx)\n", cap_type_string (slot), port);

        return X86_IOPort_In8 (slot, port);
        break;
      }
    case METHOD_X86_IOPort_In16:
      {
        word_t port = (word_t)get_mr (0);

        dbg_printf ("ubm_X86_IOPort_In16 ");

        if (cap_type (slot) != cap_X86_IOPort)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 1)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, port=%#lx)\n", cap_type_string (slot), port);

        return X86_IOPort_In16 (slot, port);
        break;
      }
    case METHOD_X86_IOPort_In32:
      {
        word_t port = (word_t)get_mr (0);

        dbg_printf ("ubm_X86_IOPort_In32 ");

        if (cap_type (slot) != cap_X86_IOPort)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 1)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, port=%#lx)\n", cap_type_string (slot), port);

        return X86_IOPort_In32 (slot, port);
        break;
      }
    case METHOD_X86_IOPort_Out8:
      {
        word_t port = (word_t)get_mr (0);
        word_t value = (word_t)get_mr (1);

        dbg_printf ("ubm_X86_IOPort_Out8 ");

        if (cap_type (slot) != cap_X86_IOPort)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 2)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, port=%#lx, value=%#lx)\n",
                    cap_type_string (slot), port, value);

        return X86_IOPort_Out8 (slot, port, value);
        break;
      }
    case METHOD_X86_IOPort_Out16:
      {
        word_t port = (word_t)get_mr (0);
        word_t value = (word_t)get_mr (1);

        dbg_printf ("ubm_X86_IOPort_Out16 ");

        if (cap_type (slot) != cap_X86_IOPort)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 2)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, port=%#lx, value=%#lx)\n",
                    cap_type_string (slot), port, value);

        return X86_IOPort_Out16 (slot, port, value);
        break;
      }
    case METHOD_X86_IOPort_Out32:
      {
        word_t port = (word_t)get_mr (0);
        word_t value = (word_t)get_mr (1);

        dbg_printf ("ubm_X86_IOPort_Out32 ");

        if (cap_type (slot) != cap_X86_IOPort)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 2)
          return return_ipc (truncated_message, 0);

        dbg_printf ("(cap:%s, port=%#lx, value=%#lx)\n",
                    cap_type_string (slot), port, value);

        return X86_IOPort_Out32 (slot, port, value);
        break;
      }
    case METHOD_X86_IOPortControl_Issue:
      {
        word_t first_port = (word_t)get_mr (0);
        word_t last_port = (word_t)get_mr (1);
        word_t index = (word_t)get_mr (2);
        uint8_t depth = (uint8_t)get_mr (3);
        cte_t *root;

        dbg_printf ("ubm_X86_IOPortControl_Issue ");

        if (cap_type (slot) != cap_X86_IOPortControl)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 4)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        root = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf ("(cap:%s, first_port=%#lx, last_port=%#lx, root=cap:%s, "
                    "index=%#lx, depth=%hhu)\n",
                    cap_type_string (slot), first_port, last_port,
                    cap_type_string (root), index, depth);

        return X86_IOPortControl_Issue (slot, first_port, last_port, root,
                                        index, depth);
        break;
      }
    case METHOD_X86_64_PDPT_Map:
      {
        word_t vaddr = (word_t)get_mr (0);
        X86_VMAttributes_t attr = (X86_VMAttributes_t)get_mr (1);
        cte_t *vspace;

        dbg_printf ("ubm_X86_64_PDPT_Map ");

        if (cap_type (slot) != cap_X86_64_PDPT)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 2)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        vspace = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf ("(cap:%s, vspace=cap:%s, vaddr=%#lx, attr=%#lx)\n",
                    cap_type_string (slot), cap_type_string (vspace), vaddr,
                    attr);

        return X86_64_PDPT_Map (slot, vspace, vaddr, attr);
        break;
      }
    case METHOD_X86_64_PDPT_Unmap:
      {

        dbg_printf ("ubm_X86_64_PDPT_Unmap ");

        if (cap_type (slot) != cap_X86_64_PDPT)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return X86_64_PDPT_Unmap (slot);
        break;
      }
    case METHOD_X86_PD_Map:
      {
        word_t vaddr = (word_t)get_mr (0);
        X86_VMAttributes_t attr = (X86_VMAttributes_t)get_mr (1);
        cte_t *vspace;

        dbg_printf ("ubm_X86_PD_Map ");

        if (cap_type (slot) != cap_X86_PD)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 2)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        vspace = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf ("(cap:%s, vspace=cap:%s, vaddr=%#lx, attr=%#lx)\n",
                    cap_type_string (slot), cap_type_string (vspace), vaddr,
                    attr);

        return X86_PD_Map (slot, vspace, vaddr, attr);
        break;
      }
    case METHOD_X86_PD_Unmap:
      {

        dbg_printf ("ubm_X86_PD_Unmap ");

        if (cap_type (slot) != cap_X86_PD)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return X86_PD_Unmap (slot);
        break;
      }
    case METHOD_X86_PT_Map:
      {
        word_t vaddr = (word_t)get_mr (0);
        X86_VMAttributes_t attr = (X86_VMAttributes_t)get_mr (1);
        cte_t *vspace;

        dbg_printf ("ubm_X86_PT_Map ");

        if (cap_type (slot) != cap_X86_PT)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 2)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        vspace = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf ("(cap:%s, vspace=cap:%s, vaddr=%#lx, attr=%#lx)\n",
                    cap_type_string (slot), cap_type_string (vspace), vaddr,
                    attr);

        return X86_PT_Map (slot, vspace, vaddr, attr);
        break;
      }
    case METHOD_X86_PT_Unmap:
      {

        dbg_printf ("ubm_X86_PT_Unmap ");

        if (cap_type (slot) != cap_X86_PT)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return X86_PT_Unmap (slot);
        break;
      }
    case METHOD_X86_Page_Map:
      {
        word_t vaddr = (word_t)get_mr (0);
        X86_VMAttributes_t attr = (X86_VMAttributes_t)get_mr (1);
        cte_t *vspace;

        dbg_printf ("ubm_X86_Page_Map ");

        if (cap_type (slot) != cap_X86_Page)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 2)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        vspace = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf ("(cap:%s, vspace=cap:%s, vaddr=%#lx, attr=%#lx)\n",
                    cap_type_string (slot), cap_type_string (vspace), vaddr,
                    attr);

        return X86_Page_Map (slot, vspace, vaddr, attr);
        break;
      }
    case METHOD_X86_Page_Unmap:
      {

        dbg_printf ("ubm_X86_Page_Unmap ");

        if (cap_type (slot) != cap_X86_Page)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return X86_Page_Unmap (slot);
        break;
      }
    case METHOD_IRQControl_get:
      {
        word_t irq = (word_t)get_mr (0);
        word_t index = (word_t)get_mr (1);
        uint8_t depth = (uint8_t)get_mr (2);
        cte_t *root;

        dbg_printf ("ubm_IRQControl_get ");

        if (cap_type (slot) != cap_IRQControl)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_length (info) < 3)
          return return_ipc (truncated_message, 0);

        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        root = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf (
            "(cap:%s, irq=%#lx, root=cap:%s, index=%#lx, depth=%hhu)\n",
            cap_type_string (slot), irq, cap_type_string (root), index, depth);

        return IRQControl_get (slot, irq, root, index, depth);
        break;
      }
    case METHOD_IRQHandler_Ack:
      {

        dbg_printf ("ubm_IRQHandler_Ack ");

        if (cap_type (slot) != cap_IRQHandler)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return IRQHandler_Ack (slot);
        break;
      }
    case METHOD_IRQHandler_Clear:
      {

        dbg_printf ("ubm_IRQHandler_Clear ");

        if (cap_type (slot) != cap_IRQHandler)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return IRQHandler_Clear (slot);
        break;
      }
    case METHOD_IRQHandler_SetNotification:
      {

        cte_t *notification;

        dbg_printf ("ubm_IRQHandler_SetNotification ");

        if (cap_type (slot) != cap_IRQHandler)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return return_ipc (illegal_operation, 0);
          }
        if (get_message_extra_caps (info) < 1)
          return return_ipc (truncated_message, 0);

        notification = lookup_cap_slot_this_tcb (get_cap (0), &error);
        if (error != no_error)
          {
            err_printf ("lookup_cap failed for cap 0\n");
            set_mr (0, 0);
            return return_ipc (error, 1);
          }

        dbg_printf ("(cap:%s, notification=cap:%s)\n", cap_type_string (slot),
                    cap_type_string (notification));

        return IRQHandler_SetNotification (slot, notification);
        break;
      }
    default:
      return return_ipc (illegal_operation, 0);
    }
}
