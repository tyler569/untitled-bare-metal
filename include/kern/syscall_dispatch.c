// This file is autogenerated by './gen.rb'. Do not edit.

message_info_t
dispatch_method (cte_t *slot, message_info_t info)
{
  switch (get_message_label (info))
    {
    case METHOD_cnode_copy:
      {
        word_t dest_index = (word_t)get_mr (0);
        uint8_t dest_depth = (uint8_t)get_mr (1);
        word_t src_index = (word_t)get_mr (2);
        uint8_t src_depth = (uint8_t)get_mr (3);
        cap_rights_t rights = (cap_rights_t)get_mr (4);
        cte_t *src_root;

        dbg_printf ("cnode_copy ");

        if (cap_type (slot) != cap_cnode)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 5)
              return msg_truncated_message (len, 5);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64,
                              &src_root));

        dbg_printf (
            "(cap:%s, dest_index=%#lx, dest_depth=%hhu, src_root=cap:%s, "
            "src_index=%#lx, src_depth=%hhu, rights=%#lx)\n",
            cap_type_string (slot), dest_index, dest_depth,
            cap_type_string (src_root), src_index, src_depth, rights);

        return cnode_copy (slot, dest_index, dest_depth, src_root, src_index,
                           src_depth, rights);
        break;
      }
    case METHOD_cnode_delete:
      {
        word_t index = (word_t)get_mr (0);
        uint8_t depth = (uint8_t)get_mr (1);

        dbg_printf ("cnode_delete ");

        if (cap_type (slot) != cap_cnode)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 2)
              return msg_truncated_message (len, 2);
          }
        while (0);

        dbg_printf ("(cap:%s, index=%#lx, depth=%hhu)\n",
                    cap_type_string (slot), index, depth);

        return cnode_delete (slot, index, depth);
        break;
      }
    case METHOD_cnode_mint:
      {
        word_t dest_index = (word_t)get_mr (0);
        uint8_t dest_depth = (uint8_t)get_mr (1);
        word_t src_index = (word_t)get_mr (2);
        uint8_t src_depth = (uint8_t)get_mr (3);
        cap_rights_t rights = (cap_rights_t)get_mr (4);
        word_t badge = (word_t)get_mr (5);
        cte_t *src_root;

        dbg_printf ("cnode_mint ");

        if (cap_type (slot) != cap_cnode)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 6)
              return msg_truncated_message (len, 6);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64,
                              &src_root));

        dbg_printf (
            "(cap:%s, dest_index=%#lx, dest_depth=%hhu, src_root=cap:%s, "
            "src_index=%#lx, src_depth=%hhu, rights=%#lx, badge=%#lx)\n",
            cap_type_string (slot), dest_index, dest_depth,
            cap_type_string (src_root), src_index, src_depth, rights, badge);

        return cnode_mint (slot, dest_index, dest_depth, src_root, src_index,
                           src_depth, rights, badge);
        break;
      }
    case METHOD_cnode_debug_print:
      {

        dbg_printf ("cnode_debug_print ");

        if (cap_type (slot) != cap_cnode)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return cnode_debug_print (slot);
        break;
      }
    case METHOD_tcb_configure:
      {
        word_t fault_ep = (word_t)get_mr (0);
        word_t cspace_root_data = (word_t)get_mr (1);
        word_t vspace_root_data = (word_t)get_mr (2);
        word_t buffer = (word_t)get_mr (3);
        cte_t *cspace_root;
        cte_t *vspace_root;
        cte_t *buffer_frame;

        dbg_printf ("tcb_configure ");

        if (cap_type (slot) != cap_tcb)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 4)
              return msg_truncated_message (len, 4);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 3)
              return msg_truncated_message (len, 3);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64,
                              &cspace_root));
        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (1), 64,
                              &vspace_root));
        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (2), 64,
                              &buffer_frame));

        dbg_printf (
            "(cap:%s, fault_ep=%#lx, cspace_root=cap:%s, "
            "cspace_root_data=%#lx, vspace_root=cap:%s, "
            "vspace_root_data=%#lx, buffer=%#lx, buffer_frame=cap:%s)\n",
            cap_type_string (slot), fault_ep, cap_type_string (cspace_root),
            cspace_root_data, cap_type_string (vspace_root), vspace_root_data,
            buffer, cap_type_string (buffer_frame));

        return tcb_configure (slot, fault_ep, cspace_root, cspace_root_data,
                              vspace_root, vspace_root_data, buffer,
                              buffer_frame);
        break;
      }
    case METHOD_tcb_read_registers:
      {
        bool suspend_source = (bool)get_mr (0);
        word_t arch_flags = (word_t)get_mr (1);
        word_t count = (word_t)get_mr (2);
        user_context_t *regs = (user_context_t *)get_mr (3);

        dbg_printf ("tcb_read_registers ");

        if (cap_type (slot) != cap_tcb)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 4)
              return msg_truncated_message (len, 4);
          }
        while (0);

        dbg_printf ("(cap:%s, suspend_source=%d, arch_flags=%#lx, count=%#lx, "
                    "regs=%p)\n",
                    cap_type_string (slot), suspend_source, arch_flags, count,
                    regs);

        return tcb_read_registers (slot, suspend_source, arch_flags, count,
                                   regs);
        break;
      }
    case METHOD_tcb_resume:
      {

        dbg_printf ("tcb_resume ");

        if (cap_type (slot) != cap_tcb)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return tcb_resume (slot);
        break;
      }
    case METHOD_tcb_bind_notification:
      {

        cte_t *notification;

        dbg_printf ("tcb_bind_notification ");

        if (cap_type (slot) != cap_tcb)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64,
                              &notification));

        dbg_printf ("(cap:%s, notification=cap:%s)\n", cap_type_string (slot),
                    cap_type_string (notification));

        return tcb_bind_notification (slot, notification);
        break;
      }
    case METHOD_tcb_set_tls_base:
      {
        word_t tls_base = (word_t)get_mr (0);

        dbg_printf ("tcb_set_tls_base ");

        if (cap_type (slot) != cap_tcb)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        dbg_printf ("(cap:%s, tls_base=%#lx)\n", cap_type_string (slot),
                    tls_base);

        return tcb_set_tls_base (slot, tls_base);
        break;
      }
    case METHOD_tcb_suspend:
      {

        dbg_printf ("tcb_suspend ");

        if (cap_type (slot) != cap_tcb)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return tcb_suspend (slot);
        break;
      }
    case METHOD_tcb_write_registers:
      {
        bool resume_target = (bool)get_mr (0);
        word_t arch_flags = (word_t)get_mr (1);
        word_t count = (word_t)get_mr (2);
        user_context_t *regs = (user_context_t *)get_mr (3);

        dbg_printf ("tcb_write_registers ");

        if (cap_type (slot) != cap_tcb)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 4)
              return msg_truncated_message (len, 4);
          }
        while (0);

        dbg_printf ("(cap:%s, resume_target=%d, arch_flags=%#lx, count=%#lx, "
                    "regs=%p)\n",
                    cap_type_string (slot), resume_target, arch_flags, count,
                    regs);

        return tcb_write_registers (slot, resume_target, arch_flags, count,
                                    regs);
        break;
      }
    case METHOD_tcb_set_debug:
      {
        word_t flags = (word_t)get_mr (0);

        dbg_printf ("tcb_set_debug ");

        if (cap_type (slot) != cap_tcb)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        dbg_printf ("(cap:%s, flags=%#lx)\n", cap_type_string (slot), flags);

        return tcb_set_debug (slot, flags);
        break;
      }
    case METHOD_tcb_set_name:
      {
        char *name = (char *)get_mr (0);
        word_t len = (word_t)get_mr (1);

        dbg_printf ("tcb_set_name ");

        if (cap_type (slot) != cap_tcb)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 2)
              return msg_truncated_message (len, 2);
          }
        while (0);

        dbg_printf ("(cap:%s, name=%p, len=%#lx)\n", cap_type_string (slot),
                    name, len);

        return tcb_set_name (slot, name, len);
        break;
      }
    case METHOD_untyped_retype:
      {
        word_t type = (word_t)get_mr (0);
        word_t size_bits = (word_t)get_mr (1);
        word_t node_index = (word_t)get_mr (2);
        uint8_t node_depth = (uint8_t)get_mr (3);
        word_t node_offset = (word_t)get_mr (4);
        word_t num_objects = (word_t)get_mr (5);
        cte_t *root;

        dbg_printf ("untyped_retype ");

        if (cap_type (slot) != cap_untyped)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 6)
              return msg_truncated_message (len, 6);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64, &root));

        dbg_printf ("(cap:%s, type=%#lx, size_bits=%#lx, root=cap:%s, "
                    "node_index=%#lx, node_depth=%hhu, node_offset=%#lx, "
                    "num_objects=%#lx)\n",
                    cap_type_string (slot), type, size_bits,
                    cap_type_string (root), node_index, node_depth,
                    node_offset, num_objects);

        return untyped_retype (slot, type, size_bits, root, node_index,
                               node_depth, node_offset, num_objects);
        break;
      }
    case METHOD_x86_64_io_port_in8:
      {
        word_t port = (word_t)get_mr (0);

        dbg_printf ("x86_64_io_port_in8 ");

        if (cap_type (slot) != cap_x86_64_io_port)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        dbg_printf ("(cap:%s, port=%#lx)\n", cap_type_string (slot), port);

        return x86_64_io_port_in8 (slot, port);
        break;
      }
    case METHOD_x86_64_io_port_in16:
      {
        word_t port = (word_t)get_mr (0);

        dbg_printf ("x86_64_io_port_in16 ");

        if (cap_type (slot) != cap_x86_64_io_port)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        dbg_printf ("(cap:%s, port=%#lx)\n", cap_type_string (slot), port);

        return x86_64_io_port_in16 (slot, port);
        break;
      }
    case METHOD_x86_64_io_port_in32:
      {
        word_t port = (word_t)get_mr (0);

        dbg_printf ("x86_64_io_port_in32 ");

        if (cap_type (slot) != cap_x86_64_io_port)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        dbg_printf ("(cap:%s, port=%#lx)\n", cap_type_string (slot), port);

        return x86_64_io_port_in32 (slot, port);
        break;
      }
    case METHOD_x86_64_io_port_out8:
      {
        word_t port = (word_t)get_mr (0);
        word_t value = (word_t)get_mr (1);

        dbg_printf ("x86_64_io_port_out8 ");

        if (cap_type (slot) != cap_x86_64_io_port)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 2)
              return msg_truncated_message (len, 2);
          }
        while (0);

        dbg_printf ("(cap:%s, port=%#lx, value=%#lx)\n",
                    cap_type_string (slot), port, value);

        return x86_64_io_port_out8 (slot, port, value);
        break;
      }
    case METHOD_x86_64_io_port_out16:
      {
        word_t port = (word_t)get_mr (0);
        word_t value = (word_t)get_mr (1);

        dbg_printf ("x86_64_io_port_out16 ");

        if (cap_type (slot) != cap_x86_64_io_port)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 2)
              return msg_truncated_message (len, 2);
          }
        while (0);

        dbg_printf ("(cap:%s, port=%#lx, value=%#lx)\n",
                    cap_type_string (slot), port, value);

        return x86_64_io_port_out16 (slot, port, value);
        break;
      }
    case METHOD_x86_64_io_port_out32:
      {
        word_t port = (word_t)get_mr (0);
        word_t value = (word_t)get_mr (1);

        dbg_printf ("x86_64_io_port_out32 ");

        if (cap_type (slot) != cap_x86_64_io_port)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 2)
              return msg_truncated_message (len, 2);
          }
        while (0);

        dbg_printf ("(cap:%s, port=%#lx, value=%#lx)\n",
                    cap_type_string (slot), port, value);

        return x86_64_io_port_out32 (slot, port, value);
        break;
      }
    case METHOD_x86_64_io_port_control_issue:
      {
        word_t first_port = (word_t)get_mr (0);
        word_t last_port = (word_t)get_mr (1);
        word_t index = (word_t)get_mr (2);
        uint8_t depth = (uint8_t)get_mr (3);
        cte_t *root;

        dbg_printf ("x86_64_io_port_control_issue ");

        if (cap_type (slot) != cap_x86_64_io_port_control)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 4)
              return msg_truncated_message (len, 4);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64, &root));

        dbg_printf ("(cap:%s, first_port=%#lx, last_port=%#lx, root=cap:%s, "
                    "index=%#lx, depth=%hhu)\n",
                    cap_type_string (slot), first_port, last_port,
                    cap_type_string (root), index, depth);

        return x86_64_io_port_control_issue (slot, first_port, last_port, root,
                                             index, depth);
        break;
      }
    case METHOD_x86_64_pdpt_map:
      {
        word_t vaddr = (word_t)get_mr (0);
        x86_vm_attributes_t attr = (x86_vm_attributes_t)get_mr (1);
        cte_t *vspace;

        dbg_printf ("x86_64_pdpt_map ");

        if (cap_type (slot) != cap_x86_64_pdpt)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 2)
              return msg_truncated_message (len, 2);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64,
                              &vspace));

        dbg_printf ("(cap:%s, vspace=cap:%s, vaddr=%#lx, attr=%#lx)\n",
                    cap_type_string (slot), cap_type_string (vspace), vaddr,
                    attr);

        return x86_64_pdpt_map (slot, vspace, vaddr, attr);
        break;
      }
    case METHOD_x86_64_pd_map:
      {
        word_t vaddr = (word_t)get_mr (0);
        x86_vm_attributes_t attr = (x86_vm_attributes_t)get_mr (1);
        cte_t *vspace;

        dbg_printf ("x86_64_pd_map ");

        if (cap_type (slot) != cap_x86_64_pd)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 2)
              return msg_truncated_message (len, 2);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64,
                              &vspace));

        dbg_printf ("(cap:%s, vspace=cap:%s, vaddr=%#lx, attr=%#lx)\n",
                    cap_type_string (slot), cap_type_string (vspace), vaddr,
                    attr);

        return x86_64_pd_map (slot, vspace, vaddr, attr);
        break;
      }
    case METHOD_x86_64_pt_map:
      {
        word_t vaddr = (word_t)get_mr (0);
        x86_vm_attributes_t attr = (x86_vm_attributes_t)get_mr (1);
        cte_t *vspace;

        dbg_printf ("x86_64_pt_map ");

        if (cap_type (slot) != cap_x86_64_pt)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 2)
              return msg_truncated_message (len, 2);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64,
                              &vspace));

        dbg_printf ("(cap:%s, vspace=cap:%s, vaddr=%#lx, attr=%#lx)\n",
                    cap_type_string (slot), cap_type_string (vspace), vaddr,
                    attr);

        return x86_64_pt_map (slot, vspace, vaddr, attr);
        break;
      }
    case METHOD_x86_64_page_map:
      {
        word_t vaddr = (word_t)get_mr (0);
        x86_vm_attributes_t attr = (x86_vm_attributes_t)get_mr (1);
        cte_t *vspace;

        dbg_printf ("x86_64_page_map ");

        if (cap_type (slot) != cap_x86_64_page)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 2)
              return msg_truncated_message (len, 2);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64,
                              &vspace));

        dbg_printf ("(cap:%s, vspace=cap:%s, vaddr=%#lx, attr=%#lx)\n",
                    cap_type_string (slot), cap_type_string (vspace), vaddr,
                    attr);

        return x86_64_page_map (slot, vspace, vaddr, attr);
        break;
      }
    case METHOD_x86_64_huge_page_map:
      {
        word_t vaddr = (word_t)get_mr (0);
        x86_vm_attributes_t attr = (x86_vm_attributes_t)get_mr (1);
        cte_t *vspace;

        dbg_printf ("x86_64_huge_page_map ");

        if (cap_type (slot) != cap_x86_64_huge_page)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 2)
              return msg_truncated_message (len, 2);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64,
                              &vspace));

        dbg_printf ("(cap:%s, vspace=cap:%s, vaddr=%#lx, attr=%#lx)\n",
                    cap_type_string (slot), cap_type_string (vspace), vaddr,
                    attr);

        return x86_64_huge_page_map (slot, vspace, vaddr, attr);
        break;
      }
    case METHOD_irq_control_get:
      {
        word_t irq = (word_t)get_mr (0);
        word_t index = (word_t)get_mr (1);
        uint8_t depth = (uint8_t)get_mr (2);
        cte_t *root;

        dbg_printf ("irq_control_get ");

        if (cap_type (slot) != cap_irq_control)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_length (info);
            if (len < 3)
              return msg_truncated_message (len, 3);
          }
        while (0);

        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64, &root));

        dbg_printf (
            "(cap:%s, irq=%#lx, root=cap:%s, index=%#lx, depth=%hhu)\n",
            cap_type_string (slot), irq, cap_type_string (root), index, depth);

        return irq_control_get (slot, irq, root, index, depth);
        break;
      }
    case METHOD_irq_handler_ack:
      {

        dbg_printf ("irq_handler_ack ");

        if (cap_type (slot) != cap_irq_handler)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return irq_handler_ack (slot);
        break;
      }
    case METHOD_irq_handler_clear:
      {

        dbg_printf ("irq_handler_clear ");

        if (cap_type (slot) != cap_irq_handler)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }

        dbg_printf ("(cap:%s)\n", cap_type_string (slot));

        return irq_handler_clear (slot);
        break;
      }
    case METHOD_irq_handler_set_notification:
      {

        cte_t *notification;

        dbg_printf ("irq_handler_set_notification ");

        if (cap_type (slot) != cap_irq_handler)
          {
            err_printf ("invalid cap type: %s\n",
                        cap_type_string (cap_type (slot)));
            return msg_illegal_operation ();
          }
        do
          {
            word_t len = get_message_extra_caps (info);
            if (len < 1)
              return msg_truncated_message (len, 1);
          }
        while (0);

        TRY (lookup_cap_slot (&this_tcb->cspace_root, get_cap (0), 64,
                              &notification));

        dbg_printf ("(cap:%s, notification=cap:%s)\n", cap_type_string (slot),
                    cap_type_string (notification));

        return irq_handler_set_notification (slot, notification);
        break;
      }
    default:
      return msg_illegal_operation ();
    }
}
