// This file is autogenerated by './gen.rb'. Do not edit.

#pragma once

#include "sys/types.h"

enum object_type
{
  cap_null,
  cap_Endpoint,
  cap_Notification,
  cap_CNode,
  cap_TCB,
  cap_Untyped,
  cap_X86_IOPort,
  cap_X86_IOPortControl,
  cap_X86_64_PML4,
  cap_X86_64_PDPT,
  cap_X86_PD,
  cap_X86_PT,
  cap_X86_Page,
  cap_IRQControl,
  cap_IRQHandler,
  max_cap_type,
};

static inline const char *
cap_type_string (word_t type)
{
  switch (type)
    {
    case cap_null:
      return "null";
    case cap_Endpoint:
      return "Endpoint";
    case cap_Notification:
      return "Notification";
    case cap_CNode:
      return "CNode";
    case cap_TCB:
      return "TCB";
    case cap_Untyped:
      return "Untyped";
    case cap_X86_IOPort:
      return "X86_IOPort";
    case cap_X86_IOPortControl:
      return "X86_IOPortControl";
    case cap_X86_64_PML4:
      return "X86_64_PML4";
    case cap_X86_64_PDPT:
      return "X86_64_PDPT";
    case cap_X86_PD:
      return "X86_PD";
    case cap_X86_PT:
      return "X86_PT";
    case cap_X86_Page:
      return "X86_Page";
    case cap_IRQControl:
      return "IRQControl";
    case cap_IRQHandler:
      return "IRQHandler";
    default:
      return "unknown";
    }
}

enum method_id
{
  METHOD_invalid,
  METHOD_CNode_Copy,
  METHOD_CNode_Delete,
  METHOD_CNode_Mint,
  METHOD_CNode_Revoke,
  METHOD_CNode_DebugPrint,
  METHOD_TCB_Configure,
  METHOD_TCB_CopyRegisters,
  METHOD_TCB_ReadRegisters,
  METHOD_TCB_Resume,
  METHOD_TCB_BindNotification,
  METHOD_TCB_SetAffinity,
  METHOD_TCB_SetIPCBuffer,
  METHOD_TCB_SetSpace,
  METHOD_TCB_SetTLSBase,
  METHOD_TCB_Suspend,
  METHOD_TCB_WriteRegisters,
  METHOD_Untyped_Retype,
  METHOD_X86_IOPort_In8,
  METHOD_X86_IOPort_In16,
  METHOD_X86_IOPort_In32,
  METHOD_X86_IOPort_Out8,
  METHOD_X86_IOPort_Out16,
  METHOD_X86_IOPort_Out32,
  METHOD_X86_IOPortControl_Issue,
  METHOD_X86_64_PDPT_Map,
  METHOD_X86_64_PDPT_Unmap,
  METHOD_X86_PD_Map,
  METHOD_X86_PD_Unmap,
  METHOD_X86_PT_Map,
  METHOD_X86_PT_Unmap,
  METHOD_X86_Page_Map,
  METHOD_X86_Page_Unmap,
  METHOD_IRQControl_get,
  METHOD_IRQHandler_Ack,
  METHOD_IRQHandler_Clear,
  METHOD_IRQHandler_SetNotification,
};

enum error_code
{
  ubm_NoError,
  ubm_InvalidArgument,
  ubm_InvalidCapability,
  ubm_IllegalOperation,
  ubm_RangeError,
  ubm_AlignmentError,
  ubm_TruncatedMessage,
  ubm_DeleteFirst,
  ubm_RevokeFirst,
  ubm_NotEnoughMemory,
  ubm_FailedLookup,
  max_error_code,
};

static inline const char *
error_string (error_t error)
{
  switch (error)
    {
    case ubm_NoError:
      return "ubm NoError";
    case ubm_InvalidArgument:
      return "ubm InvalidArgument";
    case ubm_InvalidCapability:
      return "ubm InvalidCapability";
    case ubm_IllegalOperation:
      return "ubm IllegalOperation";
    case ubm_RangeError:
      return "ubm RangeError";
    case ubm_AlignmentError:
      return "ubm AlignmentError";
    case ubm_TruncatedMessage:
      return "ubm TruncatedMessage";
    case ubm_DeleteFirst:
      return "ubm DeleteFirst";
    case ubm_RevokeFirst:
      return "ubm RevokeFirst";
    case ubm_NotEnoughMemory:
      return "ubm NotEnoughMemory";
    case ubm_FailedLookup:
      return "ubm FailedLookup";
    default:
      return "unknown";
    }
}

enum syscall_number
{
  sys_Exit,
  sys_DebugWrite,
  sys_Send,
  sys_Recv,
  sys_Call,
  sys_Reply,
  sys_ReplyRecv,
  sys_NBSend,
  sys_NBRecv,
  sys_Yield,
};
