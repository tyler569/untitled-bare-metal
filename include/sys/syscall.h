// This file is autogenerated by './gen.rb'. Do not edit.

#pragma once

#include "sys/types.h"

enum object_type
{
  cap_null,
  cap_endpoint,
  cap_notification,
  cap_cnode,
  cap_tcb,
  cap_untyped,
  cap_x86_64_io_port,
  cap_x86_64_io_port_control,
  cap_x86_64_pml4,
  cap_x86_64_pdpt,
  cap_x86_64_pd,
  cap_x86_64_pt,
  cap_x86_64_page,
  cap_x86_64_huge_page,
  cap_irq_control,
  cap_irq_handler,
  max_cap_type,
};

static inline const char *
cap_type_string (word_t type)
{
  switch (type)
    {
    case cap_null:
      return "null";
    case cap_endpoint:
      return "endpoint";
    case cap_notification:
      return "notification";
    case cap_cnode:
      return "cnode";
    case cap_tcb:
      return "tcb";
    case cap_untyped:
      return "untyped";
    case cap_x86_64_io_port:
      return "x86_64_io_port";
    case cap_x86_64_io_port_control:
      return "x86_64_io_port_control";
    case cap_x86_64_pml4:
      return "x86_64_pml4";
    case cap_x86_64_pdpt:
      return "x86_64_pdpt";
    case cap_x86_64_pd:
      return "x86_64_pd";
    case cap_x86_64_pt:
      return "x86_64_pt";
    case cap_x86_64_page:
      return "x86_64_page";
    case cap_x86_64_huge_page:
      return "x86_64_huge_page";
    case cap_irq_control:
      return "irq_control";
    case cap_irq_handler:
      return "irq_handler";
    default:
      return "unknown";
    }
}

enum method_id
{
  METHOD_invalid,
  METHOD_cnode_copy,
  METHOD_cnode_delete,
  METHOD_cnode_mint,
  METHOD_cnode_revoke,
  METHOD_cnode_debug_print,
  METHOD_tcb_configure,
  METHOD_tcb_copy_registers,
  METHOD_tcb_read_registers,
  METHOD_tcb_resume,
  METHOD_tcb_bind_notification,
  METHOD_tcb_set_affinity,
  METHOD_tcb_set_ipc_buffer,
  METHOD_tcb_set_space,
  METHOD_tcb_set_tls_base,
  METHOD_tcb_suspend,
  METHOD_tcb_write_registers,
  METHOD_tcb_set_debug,
  METHOD_untyped_retype,
  METHOD_x86_64_io_port_in8,
  METHOD_x86_64_io_port_in16,
  METHOD_x86_64_io_port_in32,
  METHOD_x86_64_io_port_out8,
  METHOD_x86_64_io_port_out16,
  METHOD_x86_64_io_port_out32,
  METHOD_x86_64_io_port_control_issue,
  METHOD_x86_64_pdpt_map,
  METHOD_x86_64_pdpt_unmap,
  METHOD_x86_64_pd_map,
  METHOD_x86_64_pd_unmap,
  METHOD_x86_64_pt_map,
  METHOD_x86_64_pt_unmap,
  METHOD_x86_64_page_map,
  METHOD_x86_64_page_unmap,
  METHOD_x86_64_huge_page_map,
  METHOD_x86_64_huge_page_unmap,
  METHOD_irq_control_get,
  METHOD_irq_handler_ack,
  METHOD_irq_handler_clear,
  METHOD_irq_handler_set_notification,
};

enum error_code
{
  no_error,
  invalid_argument,
  invalid_capability,
  illegal_operation,
  range_error,
  alignment_error,
  truncated_message,
  delete_first,
  revoke_first,
  not_enough_memory,
  failed_lookup,
  max_error_code,
};

static inline const char *
error_string (error_t error)
{
  switch (error)
    {
    case no_error:
      return "no error";
    case invalid_argument:
      return "invalid argument";
    case invalid_capability:
      return "invalid capability";
    case illegal_operation:
      return "illegal operation";
    case range_error:
      return "range error";
    case alignment_error:
      return "alignment error";
    case truncated_message:
      return "truncated message";
    case delete_first:
      return "delete first";
    case revoke_first:
      return "revoke first";
    case not_enough_memory:
      return "not enough memory";
    case failed_lookup:
      return "failed lookup";
    default:
      return "unknown";
    }
}

enum syscall_number
{
  sys_exit,
  sys_debug_write,
  sys_send,
  sys_recv,
  sys_call,
  sys_reply,
  sys_replyrecv,
  sys_nbsend,
  sys_nbrecv,
  sys_yield,
};
